<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intermediate Topics</title>
    <link rel="stylesheet" href="../css/py-style/interm-topic.css">

    <link rel="stylesheet" href="../css/sintaxhighlight.css">
    <script src="../js/sintaxhighlight.js"></script>
    <script>hljs.initHighlightingOnLoad();</script> 
</head>
<body>
    <header>
        <img src="../src_images/Python-logo-notext.png" class="py-logo" alt="Python Logo">
        <h1>Intermediate Topics</h1>
    </header>

    <section class="content">
        <section class="list-compr">
            <h3>List Comprehensions in Python</h3>

            <p> 
                List comprehensions are a concise and powerful way to create lists in Python. <br>
                They provide a more readable and expressive syntax for generating new lists by applying an expression to each item in an existing iterable 
                (e.g., a list, tuple, string, or range). <br>
                List comprehensions are a Pythonic way to perform filtering, mapping, and transformation of data in a single line of code.
            </p>

            <p>
                The basic structure of a list comprehension consists of square brackets, containing an expression and at least one "for" clause. 
                Optionally, you can include "if" clauses to filter the elements being processed. Here's the general syntax:
            </p>

            <pre>
                <code>
                    new_list = [expression for item in iterable if condition]
                </code>
            </pre>

            <ul class="lst-ul">
                <li>`<span>expression</span>`: The operation to be performed on each item from the iterable.</li>
                <li>`<span>item</span>`: A variable that represents each element from the iterable.</li>
                <li>`<span>iterable</span>`: The source data (e.g., a list, tuple, string, or range).</li>
                <li>`<span>condition</span>` (optional): A filter that determines whether to include the item in the new list.</li>
            </ul>

            <p>
                List comprehensions can be used for various tasks, including creating new lists, transforming data, filtering data, and more. <br>
                Here are some examples:
            </p>

            <div class="var-tasks">
                <ol>
                    <li>Creating a List of Squares:</li>
            
                    <pre>
                        <code>
                            # Using a for loop
                            squares = []
                            for x in range(1, 6):
                                squares.append(x**2)
            
                            # Using a list comprehension
                            squares = [x**2 for x in range(1, 6)]
                        </code>
                    </pre>
            
                    <li>Filtering Odd Numbers:</li>
            
                    <pre>
                        <code>
                            # Using a for loop
                            numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
                            odd_numbers = []
                            for x in numbers:
                                if x % 2 != 0:
                                    odd_numbers.append(x)
            
                            # Using a list comprehension
                            odd_numbers = [x for x in numbers if x % 2 != 0]
                        </code>
                    </pre>
            
                    <li>Creating a List of Words' Lengths:</li>
            
                    <pre>
                        <code>
                            words = ["apple", "banana", "cherry", "date"]
                            word_lengths = [len(word) for word in words]
                        </code>
                    </pre>
            
                    <li>Combining Elements from Two Lists:</li>
            
                    <pre>
                        <code>
                            colors = ["red", "green", "blue"]
                            fruits = ["apple", "grape", "blueberry"]
                            colorful_fruits = [f"{color} {fruit}" for color in colors for fruit in fruits]
                        </code>
                    </pre>
            
                    <li>Conditional Transformation:</li>
            
                    <pre>
                        <code>
                            numbers = [1, 2, 3, 4, 5]
                            result = [x if x % 2 == 0 else x * 2 for x in numbers]
                        </code>
                    </pre>
                </ol>
            </div>
        
            <p>
                List comprehensions are concise and elegant, making code more readable and efficient. <br>
                However, it's essential to strike a balance between using list comprehensions and writing code that remains clear and understandable. <br>
                Complex list comprehensions can become difficult to read, so it's crucial to consider code maintainability when using this feature.
            </p>
        </section>

        <section class="lambda-func">
            <h3>Lambda Functions in Python</h3>
        
            <p>
                Lambda functions, also known as anonymous functions or lambda expressions, are a way to create small, one-line functions 
                in Python without the need for a formal `def` statement. <br>
                Lambda functions are typically used for short, simple operations, and they are defined using the `lambda` keyword.
            </p>
        
            <p>The syntax of a lambda function is as follows:</p>
        
            <pre>
                <code>
                    lambda arguments: expression
                </code>
            </pre>
        
            <ul class="lambda-ul">
                <li>`<span>lambda</span>`: The keyword that indicates the creation of a lambda function.</li>
                <li>`<span>arguments</span>`: The input arguments or parameters that the lambda function takes.</li>
                <li>`<span>expression</span>`: The single expression that the lambda function evaluates and returns.</li>
            </ul>
        
            <p>
                Lambda functions are particularly useful when you need a small, throwaway function for a specific task, especially 
                when you don't want to define a named function using the `def` statement.
            </p>
        
            <p>Here are some examples of lambda functions:</p>
        
            <div class="exp-lambda">
                <ol>
                <li>Simple Lambda Function:</li>
            
                    <pre>
                        <code>
                            # A lambda function that adds two numbers
                            add = lambda x, y: x + y
            
                            result = add(3, 5)
                            print(result)  # Output: 8
                        </code>
                    </pre>
            
                    <li>Sorting a List of Tuples:</li>
            
                    <p>Lambda functions are commonly used in sorting functions, allowing you to specify the key for sorting.</p>
            
                    <pre>
                        <code>
                            fruits = [("apple", 3), ("banana", 2), ("cherry", 5)]
                            sorted_fruits = sorted(fruits, key=lambda fruit: fruit[1])
            
                            print(sorted_fruits)
                            # Output: [('banana', 2), ('apple', 3), ('cherry', 5)]
                        </code>
                    </pre>
            
                    <li>Filtering a List:</li>
            
                    <p>Lambda functions are often used with filtering functions like `filter`.</p>
            
                    <pre>
                        <code>
                            numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
                            even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
            
                            print(even_numbers)  # Output: [2, 4, 6, 8]
                        </code>
                    </pre>
            
                    <li>Mapping a List:</li>
            
                    <p>Lambda functions are also used with mapping functions like `map`.</p>
            
            
                    <pre>
                        <code>
                            numbers = [1, 2, 3, 4, 5]
                            squared_numbers = list(map(lambda x: x**2, numbers))
            
                            print(squared_numbers)  # Output: [1, 4, 9, 16, 25]
                        </code>
                    </pre>
                </ol>
            </div>

            <p>
                While lambda functions are handy for simple operations, it's important to remember that they are limited in their functionality 
                compared to regular named functions defined with `def`. <br>
                Lambda functions are best suited for concise, single-expression tasks, and they can be particularly useful when working with 
                functions like `sorted`, `filter`, `map`, and `reduce`, where you need to provide a function as an argument.
            </p>
        </section>

        <section class="iter">
            <h3>Iterators in Python</h3>

            <p>
                <b>Iterator</b> is an object, which allows a programmer to traverse through all the elements of 
                a collection, regardless of its specific implementation. In Python, an iterator object 
                implements two methods, <b>iter()</b> and <b>next()</b>.
            </p>

            <p>String, List or Tuple objects can be used to create an Iterator.</p>

            <pre>
                <code>
                    list=[1,2,3,4]

                    it = iter(list) # this builds an iterator object
                    print (next(it)) #prints next available element in iterator

                    # Iterator object can be traversed using regular for statement

                    !usr/bin/python3
                    for x in it:
                        print (x, end=" ")
                    
                    # or using next() function

                    while True:
                        try:
                            print (next(it))
                        except StopIteration:
                            sys.exit() #you have to import sys module for this
                </code>
            </pre>
        </section>

        <section class="gent">
            <h3>Generators in Python:</h3>

            <p>
                Generators are a powerful and memory-efficient way to create iterable sequences in Python. <br>
                They allow you to define functions that can produce a sequence of values on-the-fly, as they are needed, 
                rather than storing all the values in memory at once. <br>
                This is particularly useful for dealing with large datasets, infinite sequences, or situations where memory usage is a concern.
            </p>

            <p>
             Generators are defined using functions with the `yield` keyword, and they are often referred to as "generator functions." <br>
             When a generator function is called, it returns a generator object, which can be iterated over using a `for` loop or other iteration mechanisms.
            </p>

            <p>Here's how you can create a simple generator:</p>

            <pre>
             <code>
                 def count_up_to(n):
                     i = 1
                     while i <= n:
                         yield i
                         i += 1

                 # Create a generator object
                 counter = count_up_to(5)

                 # Iterate over the generator using a for loop
                 for num in counter:
                     print(num)
             </code>
            </pre>

            <p>
                In this example, `count_up_to` is a generator function that produces numbers from 1 to `n`. <br>
                When `count_up_to(5)` is called, it doesn't immediately generate all the numbers from 1 to 5. <br>
                Instead, it returns a generator object, and each time the `for` loop requests the next value, 
                the function's execution is paused at the `yield` statement until the next value is requested. <br>
                This "lazy" generation of values reduces memory consumption.
             </p>
             
            <p>Generators can be used in various scenarios, including:</p>

            <div class="gen-scen">
                 <ol>
                    <li><span>Infinite Sequences:</span>
                        You can create generators that produce an infinite sequence of values, like counting numbers indefinitely or generating an infinite stream of data.
                    </li>
            
                    <li><span>Large Datasets:</span>
                        When working with large datasets that don't fit into memory, generators allow you to process data one piece at a time, 
                        without loading the entire dataset into memory.
                    </li>
            
                    <li><span>Efficient Iteration:</span>
                        In situations where you only need to iterate through a sequence once, generators are more memory-efficient than creating a list or tuple.
                    </li>
            
                    <li><span>Processing Streams:</span>
                        Generators are commonly used for processing streams of data, such as reading lines from a large file or processing data from a continuous source 
                        like a sensor.
                    </li>

                    <li><span>Fibonacci Sequence Generator</span></li>
                </ol>

                <p>Here's an example of a generator for the Fibonacci sequence:</p>

                 <pre>
                     <code>
                         def fibonacci():
                             a, b = 0, 1
                             while True:
                                 yield a
                                 a, b = b, a + b
         
                         # Create a generator object
                         fib = fibonacci()
         
                         # Print the first 10 Fibonacci numbers
                         for _ in range(10):
                             print(next(fib))
                    </code>
                 </pre>
            </div>

            <p>This generator produces the Fibonacci sequence indefinitely without consuming excessive memory.</p>

             <p>
                 Generators are a versatile and memory-efficient tool in Python that allows you to work with sequences of data in a more resource-friendly way. 
                 They can simplify code, improve performance, and enable you to work with sequences of data that would be impractical to store in memory as 
                 a list or tuple.
             </p>
        </section>

        <section class="decor">
            <h3>Decorators in Python:</h3>

            <p>
                Decorators are a powerful and flexible feature in Python that allow you to modify or enhance the behavior of functions or 
                methods without changing their code. Decorators are essentially functions themselves, 
                but they are typically used to wrap other functions, adding functionality or behavior to them. <br>
                Decorators are often used for tasks like logging, authentication, memoization, and more.
            </p>

            <p>
                Decorators are commonly applied to functions using the `@decorator_name` syntax just above the function definition. <br>
                Here's a basic structure of a decorator and how it's used:
            </p>

            <pre>
                <code>
                    @decorator
                    def some_function():
                        # Function's code here

                    # Equivalent to:
                    def some_function():
                        # Function's code here
                    some_function = decorator(some_function)
                </code>
            </pre>
        
            <p>Here are some key concepts and use cases for decorators in Python:</p>
            
            <div class="use-case-dec">
                <ol>
                    <li>Creating a Basic Decorator:</li>
            
                    <p>
                        A decorator is defined as a function that takes another function as its argument, typically named `func`. 
                        It performs some additional actions before and/or after calling `func` and returns a new function.
                    </p>
            
                    <pre>
                        <code>
                            def my_decorator(func):
                                def wrapper():
                                    print("Something is happening before the function is called.")
                                    func()
                                    print("Something is happening after the function is called.")
                                return wrapper
            
                            @my_decorator
                            def say_hello():
                                print("Hello!")
            
                            say_hello()
                        </code>
                    </pre>
            
                    <li>Decorating Functions with Arguments:</li>
            
                    <p>
                        To decorate functions with arguments, you can use `*args` and `**kwargs` to accept any number of positional and keyword arguments. 
                        This makes the decorator flexible for different function signatures.
                    </p>
            
                    <pre>
                        <code>
                            def my_decorator(func):
                                def wrapper(*args, **kwargs):
                                    print("Before the function is called.")
                                    result = func(*args, **kwargs)
                                    print("After the function is called.")
                                    return result
                                return wrapper
            
                            @my_decorator
                            def add(a, b):
                                return a + b
            
                            result = add(3, 5)
                        </code>
                    </pre>
            
                    <li>Built-in Decorators:</li>
            
                    <p>
                        Python includes several built-in decorators, such as `@staticmethod`, `@classmethod`, and `@property`, 
                        which modify the behavior of methods in classes.
                    </p>
                </ol>
            </div>
        
            <p>
                In Python, `@staticmethod`, `@classmethod`, and `@property` are built-in decorators used to modify the behavior of methods in classes. 
                These decorators are often used to define methods that have special behavior and don't require the creation of instances of the class. 
            </p>

            <p>Here's an explanation of each decorator:</p>

            <div class="expl-dec">
                <ol>
                    <li>`@staticmethod`:</li>
            
                    <p>
                        The `@staticmethod` decorator is used to define a static method in a class. <br>
                        A static method is a method that belongs to the class rather than an instance of the class. <br>
                        It does not have access to the instance's state or attributes and does not modify the class or instance. <br>
                        Static methods are often used for utility functions or methods that don't rely on instance-specific data.
                    </p>
            
                    <pre>
                        <code>
                            class MyClass:
                                def __init__(self, value):
                                    self.value = value
            
                                @staticmethod
                                def static_method():
                                    return "This is a static method."

                            # Calling the static method without creating an instance
                            result = MyClass.static_method()
                            print(result)  # Output: "This is a static method."
                        </code>
                    </pre>

                    <li>`@classmethod`:</li>

                    <p>
                        The `@classmethod` decorator is used to define a class method in a class. <br>
                        A class method is a method that is bound to the class and not the instance. <br>
                        Class methods have access to the class itself but not the instance's data. <br>
                        They are often used for alternative constructors or for methods that need to work with class-level attributes or behavior.
                    </p>

                    <pre>
                        <code>
                            class MyClass:
                                class_variable = "Class Variable"

                                def __init__(self, value):
                                    self.value = value

                                @classmethod
                                def class_method(cls):
                                    return cls.class_variable

                            # Calling the class method without creating an instance
                            result = MyClass.class_method()
                            print(result)  # Output: "Class Variable"
                        </code>
                    </pre>

                    <li>`@property`:</li>

                    <p>
                        The `@property` decorator is used to define a method as a getter for a class attribute. <br>
                        It allows you to create a method that behaves like an attribute and is accessed without parentheses. <br>
                        This is used to encapsulate the access to an attribute and can include custom logic for getting its value. <br>
                        It is often used for computed or read-only attributes.
                    </p>
            
                    <pre>
                        <code>
                            class Rectangle:
                                def __init__(self, width, height):
                                    self._width = width
                                    self._height = height
            
                                @property
                                def area(self):
                                    return self._width * self._height
            
                                @property
                                def perimeter(self):
                                    return 2 * (self._width + self._height)
            
                            # Using the @property-decorated methods like attributes
                            rect = Rectangle(5, 4)
                            print(rect.area)      # Accesses the area property
                            print(rect.perimeter) # Accesses the perimeter property
                        </code>
                    </pre>
            
                    <p>
                        With the `@property` decorator, you can make it seem like you're accessing an attribute while actually executing a method. 
                        This allows you to encapsulate logic and potentially calculate values dynamically based on the object's state.
                    </p>
            
                    <p>
                        These decorators enhance the expressiveness and maintainability of your code by clearly indicating the intent and behavior of class methods and 
                        attributes. They are especially useful when you want to provide cleaner and more Pythonic APIs for your classes.
                    </p>
            
                    <li>Chaining Multiple Decorators:</li>
            
                    <p>You can apply multiple decorators to a single function, and they will be executed in the order they are applied.</p>
            
                    <pre>
                        <code>
                            @decorator1
                            @decorator2
                            @decorator3
                            def my_function():
                                # Function's code here
                        </code>
                    </pre>

                    <li>Practical Use Cases:</li>

                    <div class="prac-usecase">
                        <ul>
                            <li><span>Logging: </span>Decorators can log function calls, arguments, and return values for debugging or monitoring purposes.</li>
                            <li><span>Caching (Memoization): </span>Decorators can store the results of function calls to avoid redundant computation, 
                                improving performance for functions with expensive calculations.</li>
                            <li><span>Authentication and Authorization: </span>Decorators can add security checks to restrict access to certain functions or resources.</li>
                            <li><span>Timing and Profiling: </span>Decorators can measure and record the execution time of functions.</li>
                            <li><span>Validation: </span>Decorators can check the validity of inputs and outputs of functions.</li>
                            <li><span>Error Handling: </span>Decorators can handle exceptions and errors in functions, providing a clean interface to handle exceptions.</li>
                        </ul>
                    </div>
                </ol>
            </div>
        
            <p>
                Decorators are a versatile tool in Python for extending or modifying the behavior of functions and methods. <br>
                They allow you to separate concerns in your code, making it more modular and easier to maintain. <br>
                When used appropriately, decorators can enhance code reusability and readability.
            </p>
        </section>
    </section>

    <footer>
        <h5>Pramu Programming Concept</h5>
    </footer>
</body>
</html>